import * as fs from "fs"
import * as path from "path"
import { neja } from "@lib"
import { Array_sortAndRemoveDuplicates } from "@util/array.ts"
import { WriteStream_submit } from "@util/node.ts"
import { UniqueNameResolver } from "./unique_name_resolver.ts"
import { formatBuildChunk, formatRuleChunk } from "./format.ts"

const COMMAND_PARAM_PATTERN = /([^$]|^)\${([^}]+)}/gm
const uniqueRuleNames = new UniqueNameResolver()
const globalVars: Record<string, neja.RuleVar> = {}

export function createOutputStreams(params: { buildDir: string }): {
	ruleOut: fs.WriteStream
	buildOut: fs.WriteStream
	endOutput: () => void
} {
	const { buildDir } = params

	let ruleOut: fs.WriteStream | null = null
	let buildOut: fs.WriteStream | null = null

	function endOutput() {
		ruleOut?.end()
		buildOut?.end()
	}

	try {
		const rulesNinjaPath = path.join(buildDir, "rules.ninja")
		ruleOut = fs.createWriteStream(rulesNinjaPath, { encoding: "utf-8" })

		const buildNinjaPath = path.join(buildDir, "build.ninja")
		buildOut = fs.createWriteStream(buildNinjaPath, { encoding: "utf-8" })
	} catch (e) {
		endOutput()
		throw e
	}

	return { ruleOut, buildOut, endOutput }
}

export async function writeHeaders(params: {
	ruleOut: fs.WriteStream
	buildOut: fs.WriteStream
	sourceDir: string
	buildDir: string
}): Promise<void> {
	const { ruleOut, buildOut, sourceDir, buildDir } = params

	uniqueRuleNames.claim("rerun_neja")

	await WriteStream_submit(ruleOut, `# Generated by neja\n\n`)

	globalVars.sourcedir = new neja.RuleVar("sourcedir")
	globalVars.builddir = new neja.RuleVar("builddir")

	await WriteStream_submit(
		buildOut,
		`# Generated by neja\n\n` +
			`sourcedir = ${sourceDir}\n` +
			`builddir = ${buildDir}\n\n` +
			"include rules.ninja\n\n" +
			"build always_dirty: phony\n\n",
	)
}

export async function drainBuilds(): Promise<void> {
	for (let i = 0; i < neja.allBuilds.length; ++i) {
		const build = neja.allBuilds[i]

		if (build.effect !== neja.Build.prototype.effect) {
			// Call conditionally to improve parallelism.
			await neja.drainDiscoveryTasks()
			build.effect()
		}
	}
}

export async function resolveRules(params: {
	ruleOut: fs.WriteStream
	buildOut: fs.WriteStream
	imports: string[]
}): Promise<void> {
	const { ruleOut, buildOut, imports } = params

	for (const fileUrl of imports) {
		const nejafile = neja.maybeNejafile(fileUrl)
		if (nejafile && nejafile !== neja.rerun.mainNejafile.item) {
			neja.rerun.implicitIns.onFileItem(nejafile)
		}
	}

	const buildCount = neja.allBuilds.length
	for (let i = 0; i < buildCount; ++i) {
		const build = neja.allBuilds[i]
		await resolveRules_single(build, ruleOut, buildOut)
	}

	if (neja.allBuilds.length > buildCount) {
		// TODO: Should probably be done actively in the Build constructor. We should also cover other
		// prohibited operations.
		throw new Error("New builds were added while resolving rules.")
	}
}

async function resolveRules_single(
	build: neja.Build,
	ruleOut: fs.WriteStream,
	buildOut: fs.WriteStream,
): Promise<void> {
	// We later hack those, so disallow to avoid problems.
	if ("in" in build || "out" in build) {
		throw new Error('Properties "in" and "out" are reserved.')
	}

	const buildClass = build.buildClass

	const {
		command,
		description = "",
		name: baseName = buildClass.name || build.exportName,
		generator = false,
	} = build.rule()

	const ninjaRules = buildClass.ninjaRules
	let ninjaRule = ninjaRules.get(command)

	if (!ninjaRule) {
		const availableVars = build.vars
		const usedVars = new Array<string>()
		drainBuilds_scanVars(availableVars, command, usedVars)
		drainBuilds_scanVars(availableVars, description, usedVars)
		Array_sortAndRemoveDuplicates(usedVars)

		const uniqueName = uniqueRuleNames.claim(baseName)

		ninjaRule = {
			baseName,
			uniqueName,
			command,
			description,
			vars: usedVars,
			generator,
		}
		ninjaRules.set(command, ninjaRule)

		const ruleChunk = formatRuleChunk(ninjaRule)
		await WriteStream_submit(ruleOut, ruleChunk)
	} else {
		if (ninjaRule.baseName !== baseName) {
			throw new Error("Ninja rule name mismatch for the same command.")
		}
		if (ninjaRule.description !== description) {
			throw new Error("Ninja rule description mismatch for the same command.")
		}
		if (ninjaRule.generator !== generator) {
			throw new Error("Ninja rule generator flag mismatch for the same command.")
		}
	}

	const buildChunk = formatBuildChunk(build, ninjaRule)
	await WriteStream_submit(buildOut, buildChunk)
}

function drainBuilds_scanVars(
	availableVars: Record<string, neja.RuleVar>,
	text: string,
	usedVars: string[],
) {
	for (const match of text.matchAll(COMMAND_PARAM_PATTERN)) {
		const key = match[2]

		// They are implicit
		if (key === "in" || key === "out") {
			continue
		}

		if (!(key in availableVars)) {
			if (key in globalVars) {
				continue
			}
			throw new Error(`Unrecognized variable: \${${key}}`)
		}

		usedVars.push(key)
	}
}
