import * as fs from "fs"
import { neja } from "@lib"
import { Array_sortAndRemoveDuplicates } from "@util/array.ts"
import { WriteStream_submit } from "@util/node.ts"
import { UniqueNameResolver } from "./unique_name_resolver.ts"
import { formatBuildChunk, formatDefaultTargets, formatRuleChunk } from "./format.ts"

const COMMAND_PARAM_PATTERN = /([^$]|^)\${([^}]+)}/gm
const uniqueRuleNames = new UniqueNameResolver()
const uniqueAnonTargetNames = new UniqueNameResolver()
const globalVars: Record<string, neja.RuleVar> = {}

export async function processImports(
	imports: string[],
): Promise<{ defaultTargets: Set<neja.Rule> }> {
	const nejafiles = new Array<{
		file: neja.File
		importUrl: string
	}>()

	for (const fileUrl of imports) {
		const nejafile = neja.maybeNejafile(fileUrl)
		if (nejafile) {
			nejafiles.push({ file: nejafile, importUrl: fileUrl })
		}
	}

	// Sorting for two reasons:
	//  1. In case a target is re-exported from multiple files, we want to infer the name from the
	//     highest one.
	//  2. Deterministic output, as the files are included as the dependencies for thee "rerun"
	//     statement
	nejafiles.sort((a, b) => (a.file.path < b.file.path ? -1 : 1))

	const defaultTargets = new Set<neja.Rule>()

	for (const { file: nejafile, importUrl } of nejafiles) {
		neja.pipe(nejafile, neja.rerun.implicitIns)

		// Completes immediately because it was already imported.
		const module = (await import(importUrl)) as object

		let defaultExport: unknown

		for (const [key, value] of Object.entries(module)) {
			if (key === "default") {
				defaultExport = value
			} else if (value instanceof neja.Rule) {
				value.exportingFile ||= nejafile
				value.exportName ||= key
			}
		}

		// Normal exports take priority over default exports for `exportName` inference.
		if (defaultExport) {
			if (defaultExport instanceof neja.Rule) {
				defaultExport.exportingFile ||= nejafile
				defaultTargets.add(defaultExport)
			} else if (typeof defaultExport === "object") {
				for (const [key, value] of Object.entries(defaultExport)) {
					if (value instanceof neja.Rule) {
						value.exportingFile ||= nejafile
						value.exportName ||= key
						defaultTargets.add(value)
					}
				}
			}
		}
	}

	return { defaultTargets }
}

export async function executeRuleEffects(): Promise<void> {
	const { allRules } = neja.internal

	for (let i = 0; i < allRules.length; ++i) {
		const rule = allRules[i]

		if (rule.effect !== neja.Rule.prototype.effect) {
			// Call conditionally to improve parallelism.
			await neja.drainDiscoveryTasks()
			rule.effect()
		}
	}

	for (const rule of allRules) {
		if (rule.outs.length === 0 && !rule.exportName) {
			// Conflicts with maliciously crafter user names still possible, but we don't care. They will be
			// flagged by Ninja.
			rule.exportName = uniqueAnonTargetNames.claim(rule.ruleClass.name)
		}
	}
}

export function createOutputStreams(params: { ruleFile: neja.File; buildFile: neja.File }): {
	ruleOut: fs.WriteStream
	buildOut: fs.WriteStream
	endOutput: () => void
} {
	const { ruleFile, buildFile } = params

	let ruleOut: fs.WriteStream | null = null
	let buildOut: fs.WriteStream | null = null

	function endOutput() {
		ruleOut?.end()
		buildOut?.end()
	}

	try {
		ruleOut = fs.createWriteStream(ruleFile.path, { encoding: "utf-8" })
		buildOut = fs.createWriteStream(buildFile.path, { encoding: "utf-8" })
	} catch (e) {
		endOutput()
		throw e
	}

	return { ruleOut, buildOut, endOutput }
}

export async function writeHeaders(params: {
	ruleOut: fs.WriteStream
	buildOut: fs.WriteStream
}): Promise<void> {
	const { ruleOut, buildOut } = params

	uniqueRuleNames.claim("rerun_neja")

	await WriteStream_submit(ruleOut, `# Generated by neja\n\n`)

	globalVars.sourcedir = new neja.RuleVar("sourcedir")
	globalVars.builddir = new neja.RuleVar("builddir")

	await WriteStream_submit(
		buildOut,
		`# Generated by neja\n\n` +
			`sourcedir = ${neja.sourceRoot.path}\n` +
			`builddir = ${neja.buildRoot.path}\n\n` +
			"include rules.ninja\n\n" +
			"build always_dirty: phony\n\n",
	)
}

export async function resolveRules(params: {
	ruleOut: fs.WriteStream
	buildOut: fs.WriteStream
}): Promise<void> {
	const { ruleOut, buildOut } = params

	const { allRules } = neja.internal
	const ruleCount = allRules.length
	for (let i = 0; i < ruleCount; ++i) {
		const rule = allRules[i]
		await resolveRules_single(rule, ruleOut, buildOut)
	}

	if (allRules.length > ruleCount) {
		// TODO: Should probably be done actively in the Rule constructor. We should also cover other
		// prohibited operations.
		throw new Error("New rules were added while resolving rules.")
	}
}

async function resolveRules_single(
	rule: neja.Rule,
	ruleOut: fs.WriteStream,
	buildOut: fs.WriteStream,
): Promise<void> {
	// We later hack those, so disallow to avoid problems.
	if ("in" in rule || "out" in rule) {
		throw new Error('Properties "in" and "out" are reserved.')
	}

	const ruleClass = rule.ruleClass

	const {
		command,
		description = "",
		name: baseName = ruleClass.name || rule.exportName,
		depfile = "",
		generator = false,
	} = rule.command()

	const ninjaRules = ruleClass.ninjaRules
	let ninjaRule = ninjaRules.get(command)

	if (!ninjaRule) {
		const availableVars = rule.vars
		const usedVars = new Array<string>()
		resolveRules_scanVars(availableVars, command, usedVars)
		resolveRules_scanVars(availableVars, description, usedVars)
		resolveRules_scanVars(availableVars, depfile, usedVars)
		Array_sortAndRemoveDuplicates(usedVars)

		const uniqueName = uniqueRuleNames.claim(baseName)

		ninjaRule = {
			baseName,
			uniqueName,
			command,
			description,
			depfile,
			vars: usedVars,
			generator,
		}
		ninjaRules.set(command, ninjaRule)

		const ruleChunk = formatRuleChunk(ninjaRule)
		await WriteStream_submit(ruleOut, ruleChunk)
	} else {
		if (ninjaRule.baseName !== baseName) {
			throw new Error("Ninja rule name mismatch for the same command.")
		}
		if (ninjaRule.description !== description) {
			throw new Error("Ninja rule description mismatch for the same command.")
		}
		if (ninjaRule.depfile !== depfile) {
			throw new Error("Ninja rule depfile mismatch for the same command.")
		}
		if (ninjaRule.generator !== generator) {
			throw new Error("Ninja rule generator flag mismatch for the same command.")
		}
	}

	const buildChunk = formatBuildChunk(rule, ninjaRule)
	await WriteStream_submit(buildOut, buildChunk)
}

function resolveRules_scanVars(
	availableVars: Record<string, neja.RuleVar>,
	text: string,
	usedVars: string[],
) {
	for (const match of text.matchAll(COMMAND_PARAM_PATTERN)) {
		const key = match[2]

		// They are implicit
		if (key === "in" || key === "out") {
			continue
		}

		if (!(key in availableVars)) {
			if (key in globalVars) {
				continue
			}
			throw new Error(`Unrecognized variable: \${${key}}`)
		}

		usedVars.push(key)
	}
}

export async function writeDefaultTargets(
	defaultTargets: Set<neja.Rule>,
	buildOut: fs.WriteStream,
): Promise<void> {
	const defaultTargetsChunk = formatDefaultTargets(defaultTargets)
	return WriteStream_submit(buildOut, defaultTargetsChunk)
}
