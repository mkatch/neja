import * as fs from "fs"
import { neja } from "@lib"
import { Array_sortAndRemoveDuplicates } from "@util/array.ts"
import { WriteStream_submit } from "@util/node.ts"
import { UniqueNameResolver } from "./unique_name_resolver.ts"
import { formatBuildChunk, formatRuleChunk } from "./format.ts"

const COMMAND_PARAM_PATTERN = /([^$]|^)\${([^}]+)}/gm
const uniqueRuleNames = new UniqueNameResolver()
const globalVars: Record<string, neja.RuleVar> = {}

export function createOutputStreams(params: {
	ruleFile: neja.File,
	buildFile: neja.File,
}): {
	ruleOut: fs.WriteStream
	buildOut: fs.WriteStream
	endOutput: () => void
} {
	const { ruleFile, buildFile } = params

	let ruleOut: fs.WriteStream | null = null
	let buildOut: fs.WriteStream | null = null

	function endOutput() {
		ruleOut?.end()
		buildOut?.end()
	}

	try {
		ruleOut = fs.createWriteStream(ruleFile.path, { encoding: "utf-8" })
		buildOut = fs.createWriteStream(buildFile.path, { encoding: "utf-8" })
	} catch (e) {
		endOutput()
		throw e
	}

	return { ruleOut, buildOut, endOutput }
}

export async function writeHeaders(params: {
	ruleOut: fs.WriteStream
	buildOut: fs.WriteStream
}): Promise<void> {
	const { ruleOut, buildOut} = params

	uniqueRuleNames.claim("rerun_neja")

	await WriteStream_submit(ruleOut, `# Generated by neja\n\n`)

	globalVars.sourcedir = new neja.RuleVar("sourcedir")
	globalVars.builddir = new neja.RuleVar("builddir")

	await WriteStream_submit(
		buildOut,
		`# Generated by neja\n\n` +
			`sourcedir = ${neja.sourceRoot.path}\n` +
			`builddir = ${neja.buildRoot.path}\n\n` +
			"include rules.ninja\n\n" +
			"build always_dirty: phony\n\n",
	)
}

export async function drainRules(): Promise<void> {
	const { allRules } = neja.internal
	for (let i = 0; i < allRules.length; ++i) {
		const rule = allRules[i]

		if (rule.effect !== neja.Rule.prototype.effect) {
			// Call conditionally to improve parallelism.
			await neja.drainDiscoveryTasks()
			rule.effect()
		}
	}
}

export async function resolveRules(params: {
	ruleOut: fs.WriteStream
	buildOut: fs.WriteStream
	imports: string[]
}): Promise<void> {
	const { ruleOut, buildOut, imports } = params

	for (const fileUrl of imports) {
		const nejafile = neja.maybeNejafile(fileUrl)
		if (nejafile && nejafile !== neja.rerun.mainNejafile.item) {
			neja.pipe(nejafile, neja.rerun.implicitIns)
		}
	}

	const { allRules } = neja.internal
	const ruleCount = allRules.length
	for (let i = 0; i < ruleCount; ++i) {
		const rule = allRules[i]
		await resolveRules_single(rule, ruleOut, buildOut)
	}

	if (allRules.length > ruleCount) {
		// TODO: Should probably be done actively in the Rule constructor. We should also cover other
		// prohibited operations.
		throw new Error("New rules were added while resolving rules.")
	}
}

async function resolveRules_single(
	rule: neja.Rule,
	ruleOut: fs.WriteStream,
	buildOut: fs.WriteStream,
): Promise<void> {
	// We later hack those, so disallow to avoid problems.
	if ("in" in rule || "out" in rule) {
		throw new Error('Properties "in" and "out" are reserved.')
	}

	const ruleClass = rule.ruleClass

	const {
		command,
		description = "",
		name: baseName = ruleClass.name || rule.exportName,
		generator = false,
	} = rule.command()

	const ninjaRules = ruleClass.ninjaRules
	let ninjaRule = ninjaRules.get(command)

	if (!ninjaRule) {
		const availableVars = rule.vars
		const usedVars = new Array<string>()
		resolveRules_scanVars(availableVars, command, usedVars)
		resolveRules_scanVars(availableVars, description, usedVars)
		Array_sortAndRemoveDuplicates(usedVars)

		const uniqueName = uniqueRuleNames.claim(baseName)

		ninjaRule = {
			baseName,
			uniqueName,
			command,
			description,
			vars: usedVars,
			generator,
		}
		ninjaRules.set(command, ninjaRule)

		const ruleChunk = formatRuleChunk(ninjaRule)
		await WriteStream_submit(ruleOut, ruleChunk)
	} else {
		if (ninjaRule.baseName !== baseName) {
			throw new Error("Ninja rule name mismatch for the same command.")
		}
		if (ninjaRule.description !== description) {
			throw new Error("Ninja rule description mismatch for the same command.")
		}
		if (ninjaRule.generator !== generator) {
			throw new Error("Ninja rule generator flag mismatch for the same command.")
		}
	}

	const buildChunk = formatBuildChunk(rule, ninjaRule)
	await WriteStream_submit(buildOut, buildChunk)
}

function resolveRules_scanVars(
	availableVars: Record<string, neja.RuleVar>,
	text: string,
	usedVars: string[],
) {
	for (const match of text.matchAll(COMMAND_PARAM_PATTERN)) {
		const key = match[2]

		// They are implicit
		if (key === "in" || key === "out") {
			continue
		}

		if (!(key in availableVars)) {
			if (key in globalVars) {
				continue
			}
			throw new Error(`Unrecognized variable: \${${key}}`)
		}

		usedVars.push(key)
	}
}
