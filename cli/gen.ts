import * as fs from "fs"
import * as path from "path"
import { allBuilds, type Build, RuleVar } from "../def/build.ts"
import { Array_sortAndRemoveDuplicates } from "../util/array.ts"
import { WriteStream_safeWrite } from "../util/node.ts"
import { UniqueNameResolver } from "./unique_name_resolver.ts"
import { formatBuildChunk, formatRuleChunk } from "./format.ts"
import { drainDiscoveryTasks } from "../def/scheduling.ts"

const COMMAND_PARAM_PATTERN = /([^$]|^)\${([^}]+)}/gm
const uniqueRuleNames = new UniqueNameResolver()

export async function drainBuilds(params: { sourceDir: string; buildDir: string }): Promise<void> {
	const { sourceDir, buildDir } = params

	const rulesNinjaPath = path.join(buildDir, "rules.ninja")
	const buildNinjaPath = path.join(buildDir, "build.ninja")

	const ruleOut = fs.createWriteStream(rulesNinjaPath, { encoding: "utf-8" })
	const buildOut = fs.createWriteStream(buildNinjaPath, { encoding: "utf-8" })

	try {
		await WriteStream_safeWrite(ruleOut, `# Generated by neja\n\n`)
		await WriteStream_safeWrite(
			buildOut,
			`# Generated by neja\n\n` +
				`sourcedir = ${sourceDir}\n` +
				`builddir = ${buildDir}\n\n` +
				"include rules.ninja\n\n",
		)

		for (let i = 0; i < allBuilds.length; ++i) {
			const build = allBuilds[i]
			await drainBuilds_single(build, ruleOut, buildOut)
		}
	} finally {
		ruleOut.end()
		buildOut.end()
	}
}

async function drainBuilds_single(
	build: Build,
	ruleOut: fs.WriteStream,
	buildOut: fs.WriteStream,
): Promise<void> {
	// We later hack those, so disallow to avoid problems.
	if ("in" in build || "out" in build) {
		throw new Error('Properties "in" and "out" are reserved.')
	}

	const buildClass = build.buildClass

	await drainDiscoveryTasks()

	const {
		command,
		description = "",
		name: baseName = buildClass.name || build.exportName,
	} = build.rule()

	const ninjaRules = buildClass.ninjaRules
	let ninjaRule = ninjaRules.get(command)

	if (!ninjaRule) {
		const availableVars = build.vars
		const usedVars = new Array<string>()
		drainBuilds_scanVars(availableVars, command, usedVars)
		drainBuilds_scanVars(availableVars, description, usedVars)
		Array_sortAndRemoveDuplicates(usedVars)

		const uniqueName = uniqueRuleNames.claim(baseName)

		ninjaRule = {
			baseName,
			uniqueName,
			command,
			description,
			vars: usedVars,
		}
		ninjaRules.set(command, ninjaRule)

		const ruleChunk = formatRuleChunk(ninjaRule)
		await WriteStream_safeWrite(ruleOut, ruleChunk)
	} else {
		if (ninjaRule.baseName !== baseName) {
			throw new Error("Ninja rule name mismatch for the same command.")
		}
		if (ninjaRule.description !== description) {
			throw new Error("Ninja rule description mismatch for the same command.")
		}
	}

	const buildChunk = formatBuildChunk(build, ninjaRule)
	await WriteStream_safeWrite(buildOut, buildChunk)
}

function drainBuilds_scanVars(
	availableVars: Record<string, RuleVar>,
	text: string,
	usedVars: string[],
) {
	for (const match of text.matchAll(COMMAND_PARAM_PATTERN)) {
		const key = match[2]

		// They are implicit
		if (key === "in" || key === "out") {
			continue
		}

		if (!(key in availableVars)) {
			throw new Error(`Unrecognized variable: \${${key}}`)
		}

		usedVars.push(key)
	}
}
